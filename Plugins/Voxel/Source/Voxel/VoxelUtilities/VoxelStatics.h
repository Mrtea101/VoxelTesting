
#pragma once

#include "CoreMinimal.h"

// Source: https://paulbourke.net/geometry/polygonise/

static class VoxelStatics
{
public:
    //a2fVertexOffset lists the positions, relative to vertex0, of each of the 8 vertices of a cube
    static const float a2fVertexOffset[8][3];

    //a2iEdgeConnection lists the index of the endpoint vertices for each of the 12 edges of the cube
    static const int a2iEdgeConnection[12][2];

    //a2fEdgeDirection lists the direction vector (vertex1-vertex0) for each edge in the cube
    static const float a2fEdgeDirection[12][3];

    //a2iTetrahedronEdgeConnection lists the index of the endpoint vertices for each of the 6 edges of the tetrahedron
    static const int a2iTetrahedronEdgeConnection[6][2];

    //a2iTetrahedronEdgeConnection lists the index of verticies from a cube 
    // that made up each of the six tetrahedrons within the cube
    static const int a2iTetrahedronsInACube[6][4];

    // For any edge, if one vertex is inside of the surface and the other is outside of the surface
    //  then the edge intersects the surface
    // For each of the 4 vertices of the tetrahedron can be two possible states : either inside or outside of the surface
    // For any tetrahedron the are 2^4=16 possible sets of vertex states
    // This table lists the edges intersected by the surface for all 16 possible vertex states
    // There are 6 edges.  For each entry in the table, if edge #n is intersected, then bit #n is set to 1
    static int aiTetrahedronEdgeFlags[16];

    // For each of the possible vertex states listed in aiTetrahedronEdgeFlags there is a specific triangulation
    // of the edge intersection points.  a2iTetrahedronTriangles lists all of them in the form of
    // 0-2 edge triples with the list terminated by the invalid value -1.
    //
    // I generated this table by hand
    static int a2iTetrahedronTriangles[16][7];

    // For any edge, if one vertex is inside of the surface and the other is outside of the surface
    //  then the edge intersects the surface
    // For each of the 8 vertices of the cube can be two possible states : either inside or outside of the surface
    // For any cube the are 2^8=256 possible sets of vertex states
    // This table lists the edges intersected by the surface for all 256 possible vertex states
    // There are 12 edges.  For each entry in the table, if edge #n is intersected, then bit #n is set to 1
    static int aiCubeEdgeFlags[256];

    //  For each of the possible vertex states listed in aiCubeEdgeFlags there is a specific triangulation
    //  of the edge intersection points.  a2iTriangleConnectionTable lists all of them in the form of
    //  0-5 edge triples with the list terminated by the invalid value -1.
    //  For example: a2iTriangleConnectionTable[3] list the 2 triangles formed when corner[0] 
    //  and corner[1] are inside of the surface, but the rest of the cube is not.
    //
    //  I found this table in an example program someone wrote long ago.  It was probably generated by hand
    static int a2iTriangleConnectionTable[256][16];
};